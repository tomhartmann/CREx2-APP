/**
 *@file io.hpp some IO related functions
 */

#ifndef _IO_HPP_
#define _IO_HPP_

#include <fstream>
#include <vector>

#include "genom.hpp"

/**
 * looks if the filename indicates a generated testset and extract the parameters used for
 * initialization from it
 *@param[in] filename the filename
 *@param[out] m 		the number of species
 *@param[out] n 		the number of genes per species
 *@param[out] k 		the number of reversals per edge
 *@param[out] r_start 	the start of the legthrange of reversals which generated the data
 *@param[out] r_end 	the end of the legthrange of reversals which generated the data
 *@return 1 if parameters could get extracted and 0 else
 */
int parseFilename(const char *filename, unsigned &m, unsigned &n, unsigned &k, unsigned &r_start, unsigned &r_end);

/**
 * (pretty) print a species name: given comma separated list of names
 * only the first entry is taken and some dots may be added if there is more then 1 entry
 * @param[in] name the name to print
 * @param[out] out the stream to write into
 * @param[in] appdots append dots
 */
void print_name(string name, ostream &out, bool appdots=true);

///**
// * read a gene bank file and gets the start and end positions of genes and cds
// * @param[in] filename name of the genebank file
// * @param[out] lenght the length of the genome
// * @param[out] genes the start and end positions of genes and cds
// * @param[out] orientation the orientation of each gene
// */
//void read_gb(const char *filename, int &length, vector<pair<int, int> > &genes,
//	vector<int> &orientation);

/**
 * read gene orders from a fasta like file
 * @param[in] fname the name of the file to read
 * @param[out] genomes the genomes as permutations
 * @param[out] names the names of the genomes as given in the file
 * @param[in] circular handle genomes as circular, i.e. shift and rotate them to the same element
 * @param[out] nmap the name map, maps the integers to the names of the genes
 * @param[in] allowdel allow deleted elements
 * @param[in] allowdup allow duplicated elements
 * @param[in] normto rotate circular genomes to the specified integer
 */
void read_genomes(const string &fname, vector<genom> &genomes, vector<string> &names, int circular,
		vector<string> &nmap, bool allowdel=false, bool allowdup=false, int normto=1 );

/**
 * read the mapping from indices to gene names from a file
 * @param[in] fname the filename
 * @return the mapping
 */
vector<string> read_namemapping(string fname);

/**
 * reads a taxafile the data should be organized as follows
 *- lines begining with # are comments and are ignored
 *- one taxa has two lines: line 1 for the name and line 2 for the gene-order
 * >Taxaname
 * 1 2 3 4 5 6 7 8 9 ...
 *@param[in] filename the name of the taxafile
 *@param[out] genomes the vector the data should be stored in
 *@param[out] names the names of the genomes
 *@param[in] circular circular/linear chromosomes
 *@param[in] normalize_to normalize circular genomes to this element (default 1)
 *
 *@todo do some checks (if it is complete data) and return something appropriate
 */
void read_taxa(const string filename, vector<genom> &genomes,
	vector<string> &names,
	char circular,
	int normalize_to=1);

/**
 * read taxonomy strings from a file, i.e. lines starting with ']'
 */
void read_taxonomy( const string &fname, vector<vector<string> > &tax );

/**
 * read taxa in a given as strings
 *@param[in] data the strings
 *@param[out] genomes the vector the data should be stored in
 *@param[out] names the names of the genomes
 *@param[in] circular circular/linear chromosomes
 *@param[in] normalize_to normalize circular genomes to this element (default 1)
 */
void read_taxa( const vector<string> &data, vector<genom> &genomes, vector<string> &names, int circular, int normalize_to=1);

/**
 * read all newick formated lines from a file and return them
 * @param[in] fname the filename
 * @param[out] trees the tree lines found in the file
 */
void read_trees( const string &fname, vector<string> &trees );

///** parses the output generated by grappa
// * it searchs for trees in newick-format and for the inversion scores found by grappa
// *@param filename the filename of the input to grappa (the function searches for 'filename'.grappa)
// *@param newick_trees vector of strings contains the trees in newick format when everything ok
// *@param min_score integer contains the minim. score found by grappa when everything ok
// *@return 1 if success; 0 else
// */
//int read_grappaClusters(const char *filename, vector< pair<string,int> > &newick_trees, int &min_score);



#endif//_IO_HPP_
